import type { Comparison } from "Compare"

import type { Tag } from "@/Tag"

import { EQ, GT, LT } from "Compare"

import { Tag } from "@/Tag"



export type MatchKind = Match | Invert | All | Any | None
export type Tagged a = Tagged(MatchKind, List Tag, a)

instance Comparable (Tagged a) {
  compare = compareTagged
}



// CONSTRUCTORS

export tagged = pipe(
  map(Tag),
  Tagged(Match),
)
export untagged = pipe(
  map(Tag),
  Tagged(Invert),
)
// no actual tags needed
export all = Tagged(All, [])
export any = Tagged(Any, [])
export none = Tagged(None, [])

// FIELDS

kind :: Tagged a -> MatchKind
export kind = where {
  Tagged(k, _, _) =>
    k
}

tags :: Tagged a -> List Tag
export tags = where {
  Tagged(_, t, _) =>
    t
}

subject :: Tagged a -> a
export subject = where {
  Tagged(_, _, s) =>
    s
}

compareTagged = (_a, _b) => {
  kA = kind(_a)
  kB = kind(_b)
  tA = tags(_a)
  tB = tags(_b)
  sA = subject(_a)
  sB = subject(_b)
  return if (kA == kB && kA == Match) {
    EQ
  } else {
    EQ
  }
}
// DERIVATIONS

fuzzy :: String -> List (Tagged a) -> List (Tagged a)
export fuzzy = (search, list) => list
