import type { Comparison } from "Compare"
import type { Maybe } from "Maybe"

import type { DistanceConfig } from "CopyEdit"

import { EQ, GT, LT } from "Compare"
import Float from "Float"
import { equals } from "Function"
import List from "List"
import { join, toLower } from "String"

import { DEFAULT_CONFIG, distanceWithConfig } from "CopyEdit"



/*

  Tags are non-empty caseless* string lists: Tag(["shop", "bakery", "Tartine"])
  
  Each index is a Scope

  The first Scope is the Root Scope
  The last Scope is the Focus Scope

  A Band is a Tag whose Root and Focus are the same value (that is, a single value Tag is a Band)

  Other tags are considered siblings if the given tags share a Root Scope

  The overlap between Tags denotes their affinity

  a. Tag(["shop", "bakery", "Tartine"])
  b. Tag(["shop", "exotic", "Paxton Gate"])

  These two tags have the same Band, "shop", and it's in the same place, so they have a stronger affinity than

  c: Tag(["airport", "shop", "Peetz", "Drip Coffee"])

  since `a` and `b` have the same Root and length, they have the same affinity to `c`

  A tag's scopes are considered left associative and should loosely allow for "is a" expansion from right to left, that is, for `a` above, "Tartine is a bakery is a shop" is true

  *A tag can have cased text but the case of the text is not used in any automatic sorting or comparison.

*/

lower = map(toLower)

export type Tag = Tag(List String)
instance Comparable Tag {
  compare = compareTag
}

create :: List String -> Tag
export create = Tag

many :: List (List String) -> List Tag
export many = map(create)


// INTRINSICS

compareTag :: Tag -> Tag -> Comparison
export compareTag = (a, b) => where(#[a, b]) {
  #[Tag(_), Tag(_)] =>
    do {
      aff = affinity(a, b)
      return aff == 0 ? EQ : aff < 0.5 ? LT : GT
    }
}

// FIELDS

scopes :: Tag -> List String
export scopes = where {
  Tag(x) =>
    x
}

render :: Tag -> String
export render = pipe(
  scopes,
  join(":"),
)

length :: Tag -> Integer
export length = pipe(
  scopes,
  List.length,
)

root :: Tag -> Maybe String
export root = pipe(
  scopes,
  List.first,
)

focus :: Tag -> Maybe String
export focus = pipe(
  scopes,
  List.last,
)

scopeAt :: Integer -> Tag -> Maybe String
export scopeAt = (i, t) => pipe(
  scopes,
  List.nth(i),
)(t)

// DERIVATIONS

isBand :: Tag -> Boolean
export isBand = pipe(
  scopes,
  List.length,
  equals(1),
)

isRootSibling :: Tag -> Tag -> Boolean
export isRootSibling = (a, b) => root(a) == root(b)

isRelative :: Tag -> Tag -> Boolean
export isRelative = (_a, _b) => where(#[_a, _b]) {
  #[Tag(a), Tag(b)] =>
    pipe(
      List.zip(a),
      List.any(where { #[k, v] => k == v }),
    )(b)
}

overlap :: Tag -> Tag -> List String
export overlap = (a, b) => where(#[a, b]) {
  #[Tag(xs), Tag(ys)] =>
    List.reduce(
      (agg, y) => List.includes(toLower(y), lower(xs)) ? List.concat(agg, [y]) : agg,
      [],
      lower(ys),
    )
}

affinity :: Tag -> Tag -> Float
export affinity = (_a, _b) => {
  dA = length(_a)
  dB = length(_b)
  d = dA > dB ? dA : dB
  n = pipe(
    overlap(_a),
    List.length,
  )(_b)
  return n / d
}

/*
fuzzyWithConfig :: DistanceConfig -> String -> List Tag -> List Tag
fuzzyWithConfig = (conf, str, tags) => pipe(

)(tags)
*/
